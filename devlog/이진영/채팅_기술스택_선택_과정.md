# 실시간 채팅 시스템 개발자 노트

이 노트는 실시간 채팅 시스템을 개발하면서 기술 스택을 선택한 과정, WebSocket과 Redis(Pub/Sub)를 조합한 이유, 그리고 프로젝트에서의 역할과 흐름을 상세히 기록한 것입니다. 실시간성과 확장성을 목표로 한 설계 과정을 중심으로, 고민했던 점과 해결 방안을 정리했습니다.

---

## 1. 기술 스택 선택 시 고민

채팅 시스템을 처음 시작할 때 가장 큰 고민은 "어떤 기술 스택을 써야 실시간성과 확장성을 모두 충족할까?"였습니다. 사용자들이 메시지를 주고받을 때 지연이 없어야 하고, 여러 명이 동시에 접속해도 안정적이어야 했습니다.

그래서 몇 가지 기술들 사이에서 고민했습니다.

### 1.1. 고려 대상 기술
고려했던 기술 스택은 다음과 같습니다:

- **WebSocket**: 클라이언트와 서버 간 양방향 통신을 지원하는 프로토콜.
- **STOMP**: WebSocket 위에서 동작하는 메시징 프로토콜로, Pub/Sub 모델 제공.
- **Redis**: 인메모리 데이터베이스로, Pub/Sub와 상태 저장 기능 포함.
- **Kafka**: 대규모 메시지 처리를 위한 분산 스트리밍 플랫폼.

---

## 2. WebSocket + Redis(Pub/Sub) 선택 이유

### 2.1. 왜 WebSocket + Redis(Pub/Sub)를 선택했나?

고민 끝에 **WebSocket + Redis(Pub/Sub)** 조합을 선택했습니다.

이유는 다음과 같습니다:

- **실시간성**: WebSocket은 지속적인 연결로 메시지를 즉시 전달.
- **간단한 구현**: Redis의 Pub/Sub는 복잡한 설정 없이 메시지 브로커 역할을 수행.
- **확장성**: Redis 클러스터링으로 중규모 트래픽까지 커버 가능.
- **적절한 리소스 사용**: Kafka처럼 무겁지 않아 초기 개발에 적합.
- **상태 관리**: Redis를 통해 읽음 상태 같은 추가 데이터를 쉽게 저장 가능.

### 2.2. 다른 기술들과의 비교

#### STOMP와 비교
- **특징**: WebSocket 위에 메시징 계층을 추가해 구조화된 통신 제공.
- **장점**:
    - 메시지 형식이 표준화되어 있어 이해하기 쉬움.
    - Redis 같은 브로커와 통합이 간편.
- **단점**:
    - 추가 계층 때문에 약간의 성능 오버헤드 발생.
    - 순수 WebSocket보다 설정이 조금 더 복잡.
    - 모니터링이 불편.
    -
- **결정**: "STOMP는 메시지 형식을 표준화해 주지만, Redis 에서도 직접 JSON으로 메시지 형식을 정의하면 충분하고 모니터링도 비교적 쉽다고 느껴서 Redis를 선택"

#### Kafka와 비교
- **특징**: 대규모 데이터 스트리밍과 메시지 처리에 특화.
- **장점**:
    - 수십만 사용자도 처리 가능.
    - 메시지 로그를 유지해 복구가 쉬움.
- **단점**:
    - 설정과 운영이 어렵고 리소스 소모가 큼.
    - 소규모 프로젝트에서는 과도한 솔루션.
- **결정**: Redis도 어느정도 중규모 까지는 충분히 커버 할 수 있다고 판단해서 Redis를 선택.

#### WebSocket 단독 vs WebSocket + Redis
- **WebSocket 단독**: 실시간성은 보장되지만, 메시지를 여러 클라이언트에 배포하려면 서버에서 직접 관리해야 함.
- **WebSocket + Redis**: Redis가 메시지 배포를 대신 해줘서 서버 부담이 줄어듦.
- **결정**: Redis를 추가하면 훨씬 효율적으로 메시지를 배포할수 있음.

### 2.3. 결론
WebSocket으로 실시간 통신을 보장하고, Redis로 메시지 배포와 상태 관리를 처리하는 방식이 현재 프로젝트에 가장 적합하다고 판단했습니다. STOMP는 약간 무겁게 느껴졌고, Kafka는 규모 대비 필요 이상의 복잡성을 가져올 것 같았습니다.

---