# 실시간 채팅 시스템 개발자 노트


이 노트는 실시간 채팅 시스템을 개발하면서 기술 스택을 선택한 과정, WebSocket과 Redis(Pub/Sub)를 조합한 이유, 
그리고 프로젝트에서의 역할과 흐름을 기록한 것입니다. 
실시간성과 확장성을 목표로 한 설계 과정을 중심으로, 고민했던 점과 해결 방안을 정리했습니다.

## 1. 기술 스택 선택 시 고민

채팅 시스템 개발을 시작할 때 가장 큰 고민은 **"어떤 기술 스택을 사용해야 실시간성과 확장성을 모두 충족할 수 있을까?"** 였습니다.  
사용자들이 메시지를 주고받을 때 지연 없이 즉시 반영되어야 하고, 여러 명이 동시에 접속해도 안정적이어야 했습니다.

초기에는 HTTP API 기반으로 설계했지만, 실시간성을 강화하기 위해 WebSocket 중심으로 전환하며 다양한 기술을 검토했습니다.

### 1.1. 고려 대상 기술

고려했던 기술 스택은 다음과 같습니다:

- **HTTP API (REST)**: 전통적인 요청-응답 방식으로 메시지 전송.
- **WebSocket**: 클라이언트와 서버 간 양방향 통신을 지원하는 프로토콜.
- **STOMP**: WebSocket 위에서 동작하는 메시징 프로토콜로, Pub/Sub 모델 제공.
- **Redis**: 인메모리 데이터베이스로, Pub/Sub와 상태 저장 기능 포함.

---

## 2. WebSocket + Redis(Pub/Sub) 선택 이유

### 2.1. 왜 WebSocket + Redis(Pub/Sub)를 선택했나?

초기에는 **HTTP API(POST /api/chats/{roomId}/message)로 메시지를 전송하고 WebSocket으로 수신하는 하이브리드 방식**을 사용했습니다.  
하지만 실시간성을 극대화하고 클라이언트-서버 간 통신을 단순화하기 위해 메시지 전송도 WebSocket으로 전환했습니다.

최종적으로 **WebSocket + Redis(Pub/Sub) 조합을 선택한 이유**는 다음과 같습니다:

- **실시간성**: WebSocket은 지속적인 연결로 메시지를 즉시 송수신하며, 전송과 수신을 단일 채널로 통합 가능.
- **간단한 구현**: Redis의 Pub/Sub는 복잡한 설정 없이 메시지 브로커 역할을 수행하며, WebSocket과 자연스럽게 통합.
- **확장성**: Redis 클러스터링으로 중규모 트래픽까지 안정적으로 처리 가능.
- **서버 부담 감소**: Redis가 메시지 배포를 담당해 WebSocket 서버의 부하를 줄임.
- **상태 관리**: Redis로 `lastReadMessage`(마지막 읽은 메시지)를 저장하며 추가 기능 확장에 유리.

---

### 2.2. 다른 기술들과의 비교

#### HTTP API와 비교

**특징**: RESTful 방식으로 메시지 전송 및 상태 관리.

장점:
- 익숙한 구조로 초기 구현이 쉬움.
- 서버 상태를 클라이언트와 동기화하기 용이.

  단점:
- 실시간성이 떨어짐 (폴링 또는 롱 폴링 필요).
- 빈번한 API 호출로 서버 부하 증가.

**결정**: *"초기에는 API로 빠르게 구현했지만, 실시간 채팅의 핵심 요구사항인 즉각적인 메시지 반영을 위해 WebSocket으로 전환했습니다."*

#### STOMP와 비교

**특징**: WebSocket 위에 메시징 계층을 추가해 구조화된 통신 제공.

장점:
- 메시지 형식이 표준화되어 관리 용이.
- Redis 같은 브로커와 통합 가능.

  단점:
- 추가 계층으로 약간의 오버헤드 발생.
- 순수 WebSocket에 비해 설정 복잡성 증가.

**결정**: *"STOMP는 메시지 형식을 표준화하지만, Redis에서 JSON으로 직접 정의하면 충분하고 모니터링도 간단해 Redis Pub/Sub를 선택했습니다."*



#### WebSocket 단독 vs WebSocket + Redis

- **WebSocket 단독**: 실시간성은 보장되지만, 메시지 배포를 서버에서 직접 관리해야 함.
- **WebSocket + Redis**: Redis가 메시지 배포를 담당해 서버 부담 감소.

**결정**: *"WebSocket만 사용하면 서버가 모든 세션을 관리해야 하지만, Redis를 추가하면 메시지 브로드캐스트가 효율적이고 확장성이 높아집니다."*

---

## 3. 프로젝트에서의 WebSocket과 Redis 역할 및 흐름

### 3.1. WebSocket 역할

- **클라이언트 연결**: 사용자가 채팅방에 접속하면 WebSocket 연결을 설정하여 서버와 실시간 통신 채널을 유지.
- **메시지 송신**: 클라이언트가 텍스트 또는 이미지 메시지를 WebSocket을 통해 전송.
- **메시지 수신**: 서버에서 다른 사용자가 보낸 메시지를 실시간으로 수신하여 화면에 반영.

### 3.2. Redis 역할

- **메시지 브로커**: Pub/Sub 모델을 통해 서버가 보낸 메시지를 모든 관련 클라이언트에 배포.
- **채널 관리**: 각 채팅방마다 `chatroom-{chatRoomId}` 채널을 생성하여 메시지를 분리.
- **상태 저장**: 사용자의 마지막 읽은 메시지(`lastReadMessage`)를 저장하여 읽음 여부 동기화.

---

## 4. 설계 시 고민과 해결

### API → WebSocket 전환
- **고민**: API는 간단했지만 실시간성이 부족하고, 별도의 수신 로직이 필요.
- **해결**: WebSocket으로 송수신을 통합하여 지연을 줄이고 구현을 단순화.

### Redis Pub/Sub 채널 관리
- **고민**: 모든 채팅방을 단일 채널로 관리하면 메시지 충돌 가능성이 있음.
- **해결**: `chatroom-{chatRoomId}`로 채팅방별 채널을 분리하여 독립성 보장.

### 세션 관리
- **고민**: WebSocket 연결이 끊기면 메시지가 누락될 우려.
- **해결**: 서버에서 채팅방별 세션 목록을 관리하고, 연결 해제 시 세션을 정리하여 안정성을 높임.

---