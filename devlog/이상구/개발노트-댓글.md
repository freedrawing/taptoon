# 댓글 기능 설계 전략

## 개요
댓글 기능은 기본적인 기술들만 사용하여 설계했지만, 사용자의 서비스적인 측면을 고려하여 구성하였다.  
댓글 기능은 매칭포스트를 이용하는 사용자 간의 상호작용을 증가시켜 사이트 이용률을 높이는 것에 목표를 두고있다.

---

## 📌 목차
1. [**포맷**](#포맷)

    - [1.1 댓글과 답글의 관계](#11-댓글과-답글의-관계)
    - [1.2 댓글과 답글의 조회 방법](#12-댓글과-답글의-조회-방법)
        - [1.2.1 페이지네이션 구현](#121-페이지네이션-구현)
    - [1.3 댓글 삭제 시 답글 처리](#13-댓글-삭제-시-답글-처리)

2. [**목표**](#목표)
    - [2.1 실제 서비스 이용 시 댓글 구성에 따른 목표](#21-실제-서비스-이용-시-댓글-구성에-따른-목표)

3. [**트러블 슈팅**](#트러블-슈팅)
    - [3.1 NPE 방지](#31-npe-방지)

4. [**개선이 필요했던 부분**](#개선이-필요했던-부분)
    - [4.1 댓글에 답글 개수 표시 기능 미구현](#41-댓글에-답글-개수-표시-기능-미구현)
    - [4.2 댓글 및 답글 작성 시 엔티티 조회 최적화 부족](#42-댓글-및-답글-작성-시-엔티티-조회-최적화-부족)
    - [4.3 Soft Delete된 댓글 조회 문제](#43-soft-delete된-댓글-조회-문제)
    - [4.4 마무리 지으며](#44-마무리-지으며)
---

## 포맷

### 1.1 댓글과 답글의 관계
댓글과 답글은 **parentId**를 사용하여 같은 엔티티에서 관리되도록 설계되었다.  
이렇게 하면 **양방향 관계를 배제**할 수 있어 관리가 용이하고 성능 최적화에도 유리하다.

- **댓글은 최상위 계층**, **답글은 댓글의 하위 계층**이다.


- **답글은 또 다른 답글을 가질 수 없다**. 즉, **2계층 구조**로 제한된다.


- **2계층 구조**를 선택한 이유
```
    - 다수의 사이트에서 가장 일반적으로 사용되는 구조였다.
    - 다계층 구조는 UX/UI 측면에서 가독성이 떨어지고, 백엔드에서도 깊은 계층을 처리하는 것이 복잡해지는 문제가 있음.
    - 2계층 구조를 채택한 사이트들은 UI/UX가 더 직관적이며, 백엔드 성능 최적화도 비교적 잘 되어있다는 점에서 적합하다고 판단함.
```

---

### 1.2 댓글과 답글의 조회 방법
초기에는 **매칭포스트를 조회할 때 댓글과 답글을 한 번에 모두 불러오는 방식**을 고려했음.  
하지만 **페이징 처리 문제**와 **불필요한 데이터 로딩 문제**로 인해 다음과 같이 설계를 변경함.

1. **특정 포스팅에 대한 모든 댓글 조회**
2. **특정 댓글에 대한 모든 답글 조회**

이렇게 나누면 **페이징 처리가 가능**하며, 댓글 수가 많아질 경우에도 **성능 저하를 방지**할 수 있다.

또한 댓글과 답글 조회에서는 `readOnly = true 옵션을 추가`해서 읽기 전용 트랜잭션으로 설정했다.   
`@Transactional(readOnly = true)`를 사용함으로써 다음과 같은 효과를 보았다.

| 효과 | 설명 |
|------|-------------------------------------------|
| 🔹 **성능 최적화** | 불필요한 `flush()` 호출을 방지하여 성능 향상 |
| 🔹 **데이터 변경 방지** | `INSERT`, `UPDATE`, `DELETE` 작업이 차단됨 |
| 🔹 **데이터베이스 부하 감소** | `readOnly` 설정을 통해 불필요한 리소스 사용 절약 |

---

### 1.2.1 페이지네이션 구현 방식

댓글과 답글을 페이징 처리할 때 **쿼리DSL**을 활용하였다.  
쿼리DSL을 사용한 이유는 다음과 같다.

### **쿼리DSL을 사용할 때와 사용하지 않을 때의 차이점**

1. **가독성 & 유지보수성**
    - JPQL을 사용할 경우, 문자열을 직접 작성해야 하기 때문에  
      쿼리 수정이 어렵고, 런타임에서 오류를 발견해야 한다.
    - 반면, **쿼리DSL은 코드 기반**으로 작성되므로 **컴파일 타임에서 오류를 발견**할 수 있다.
   

2. **성능 최적화**
    - `join`, `where`, `group by` 등의 쿼리를 조합하는 과정에서  
      **쿼리DSL은 SQL 최적화를 자동으로 지원**한다.
    - 즉, **불필요한 데이터 조회를 방지**하고,  
      필요한 데이터만 `select`할 수 있어 성능이 향상된다.


3. **타입 안정성(Type-Safe)**
    - JPQL은 문자열로 작성되기 때문에 오타가 발생해도 컴파일러가 감지하지 못한다.
    - 하지만 **쿼리DSL은 타입을 명확하게 지정할 수 있어 오타 및 런타임 오류를 방지**할 수 있다.


사실 같이 프로젝트를 진행한 팀원인 성욱님께서 코드리뷰 때 쿼리DSL 방식을 사용해보는 것을 제안하셨고 간단하게 설명까지 해주셨다.
보면 예전에 dBeaver를 사용했을 때와 거의 비슷하게 코드가 진행돼서 생각보다 큰 어려움은 없었다. 
물론 챗지피티에도 물어보고 다른 블로그도 많이 참고했지만 코드에 대한 이해도는 다른 lecture에 비해서 괜찮았다고 스스로는 판단한다.

---

### 1.3 댓글 삭제 시 답글 처리
댓글을 삭제할 때, **해당 댓글에 달린 답글을 어떻게 처리할 것인지** 고민이 필요했다.  
다양한 서비스들을 참고한 결과, 아래 두 가지 방법이 있었다.

1. **댓글을 삭제해도 답글은 유지**
2. **댓글을 삭제하면 답글도 함께 삭제**

초기에는 **댓글 삭제 시 답글을 유지**하는 방식을 고려했지만, 결국 **댓글을 삭제하면 해당 답글도 함께 삭제**되는 방식으로 변경하였다.

### 이유
- **데이터 관리가 간결해짐**
- **삭제된 댓글의 답글을 유지할 경우 UI/UX가 어색함**
- **parentId가 `isDeleted = true`인 답글을 조회하지 않도록 추가적인 로직이 필요함**  
  → **이런 복잡성을 제거하기 위해 답글도 함께 삭제하도록 변경**

---

## 2. 목표
- 댓글 기능을 **커뮤니티 사이트 형태**로 구성할 수 있도록 기획
- **유튜브 댓글 창**을 참고하여, **유저 간 상호작용이 활발해지도록 설계**
- 향후 이모티콘, 이미지 첨부 등의 기능을 추가하여 **의사 표현을 다양화할 계획**

---

## 3. 트러블 슈팅
### 3.1 **NullPointerException 방지**

### **문제 발생**
- `Comment` 생성할 때 `requestDto`에서 `parentId`가 `null`일 경우 **NullPointerException(NPE)**이 발생함.

### **원인 분석**
- 댓글과 답글을 생성하는 API가 동일하게 동작함.
- **답글**에는 `parentId`가 필요하지만, **댓글**에는 `parentId`가 필요하지 않음.
- 따라서 `parentId`는 `(nullable = true)`로 설정되어 있음.
- 댓글을 생성할 때 `getParent()`가 `parentId`를 `null`로 반환하면서 **NPE가 발생**.
- **Null Check가 필요하지만, 이에 대한 대비가 부족**했음.

---

### **해결 과정**
- `requestDto`에서 `NPE`가 발생하는 것을 확인하고,  
  아래와 같은 **삼항 연산자**를 사용하여 해결함.

```java
@Builder
public static CommentResponse from(Comment comment) {
    return CommentResponse.builder()
            .commentId(comment.getId())
            .matchingPostId(comment.getMatchingPost().getId())
            .memberId(comment.getMember().getId())
            .memberNickname(comment.getMember().getNickname())
            .parentId(comment.getParent() != null ? comment.getParent().getId() : null)
            .content(comment.getContent())
            .createdAt(comment.getCreatedAt())
            .updatedAt(comment.getUpdatedAt())
            .build();
}

```

- 해당 코드는 정상적으로 작동하여 문제가 해결되었다고 판단했으나,  
  **유지보수 측면에서 좋은 코드가 아니므로 개선이 필요**하다는 피드백을 받음.
- **Optional을 활용하여 NPE를 방지하는 것이 더 좋은 방향**이라는 의견이 있었음.

#### **개선 코드**
```java
@Entity
public Optional<Comment> getParent() {
    return Optional.ofNullable(this.parent);
}
```

```java
@Builder
public static CommentResponse from(Comment comment, List<CommentResponse> replies) {
    return CommentResponse.builder()
        .commentId(comment.getId())
        .matchingPostId(comment.getMatchingPost().getId())
        .memberId(comment.getMember().getId())
        .memberNickname(comment.getMember().getNickname())
        .parentId(getParentId(comment)) // null checked
        .content(comment.getContent())
        .createdAt(comment.getCreatedAt())
        .updatedAt(comment.getUpdatedAt())
        .replies(replies)
        .build();
}
// Optional ParentId null check logic
private static Long getParentId(Comment comment) {
    return comment.getParent()
            .map(Comment::getId)
            .orElse(null);
}
```

- **`Optional`을 사용하면 `NPE` 발생 가능성을 최소화할 수 있음**.
- **유지보수 및 기능 확장 시에도 안정적으로 동작**할 수 있도록 개선됨.

---

### **느낀점**
#### **여러 `null check` 방법 중 선택과 그 이유**
     처음에는 삼항 연산자를 사용한 이유가 코드가 간결하고 가독성이 좋다고 판단했다.
     하지만 이 방법은 근본적인 해결책이 아니며, 이후 추가적인 문제가 발생할 가능성이 있다.
     반면, Optional을 엔티티 단계에서 사용하면 유지보수성이 높아지고, 향후 기능 확장 시에도 추가적인 NPE 발생을 방지할 수 있었다.

#### **결론**
    단순히 발생한 오류만 해결하는 것이 아니라, 근본적인 원인을 해결하는 것이 좋은 설계임을 다시 깨달았다.
    초기에 API를 댓글과 답글 생성 API로 분리했다면 발생하지 않았을 문제이지만, 설계 방식에 따라 
    코드의 안정성과 오류 발생 여부가 크게 달라진다는 것을 알게되었다. 결국 댓글과 답글 생성 API를 분리하여 
    해당 오류는 더 이상 발생하지 않게 되었다. 설계의 중요성을 다시 한번 깨닫는 계기가 되었으며, 앞으로는 보다 확장성을 고려한 개발을 해야겠다고 다짐했다.

---

### 3.2 개선이 필요했던 부분

### 3.2.1 댓글에 답글 개수 표시 기능 미구현
- 댓글에 몇 개의 답글이 달려있는지 보여주는 기능을 추가하지 못했다.
- 해당 기능을 **쿼리DSL**을 사용하여 구현하려 했으나, **시간 부족으로 인해 개발이 중단**할 수 밖에 없었다.
- 쿼리DSL을 활용하면 **댓글 ID별로 답글 개수를 그룹화하여 조회**하는 방식으로 구현할 계획이었다.
- 향후 개발을 재개하여 **프론트엔드에서 답글 개수를 쉽게 표시할 수 있도록 개선할 필요**가 있어보인다.


### 3.2.2 댓글 및 답글 작성 시 엔티티 조회 최적화 부족
- 현재 **댓글 또는 답글을 작성할 때 `member`, `matchingPost` 엔티티를 불러오는 과정에서 최적화 보충이 필요하다**.

##### **문제점**
    - 댓글을 생성할 때 `Member`와 `MatchingPost`를 조회해야 한다.
    - 하지만 단순 조회가 아닌 객체 그래프 탐색 방식으로 가져오기 때문에, 불필요한 데이터 로딩 가능성이 존재했다.
    - JPA의 Lazy Loading 전략을 사용하지만, 댓글이 많아질 경우 N+1 문제가 발생할 수도 있었다.

##### **추후 개선 방안**
    - DTO 프로젝션(QueryDSL Projections) 을 사용하여 필요한 데이터만 조회하도록 변경.
    - `@EntityGraph` 혹은 `fetch join`을 활용하여 성능 최적화.
    - 불필요한 `member.getId()`, `matchingPost.getId()` 같은 연산을 줄이고, 필요한 ID 값만 별도로 전달하여 생성.


### 3.2.3 Soft Delete된 댓글 조회 문제
- 현재 **삭제된 댓글은 `isDeleted = true`로 설정되는 Soft Delete 방식**을 사용.
- `@Where(clause = "is_deleted = false")` 어노테이션을 활용하여 Soft Delete된 댓글을 자동으로 조회에서 제외하도록 설정.

##### **이 방식의 문제점**
    - 간단한 설정으로 모든 API에서 Soft Delete가 적용된 댓글을 자동으로 제외할 수 있음.
    - 하지만, 삭제된 댓글을 특정 조건에서 조회해야 하는 경우, @Where 어노테이션이 걸림돌이 될 수 있음.
    - 예를 들어 관리자 페이지에서 삭제된 댓글을 복구해야 할 경우 별도의 쿼리를 작성해야 함.
    - Soft Delete 적용된 데이터를 관리자 권한으로 조회할 API를 추가적으로 설계해야 하는 필요성이 있음.

##### **추후 개선 방안**
    - Soft Delete된 데이터를 조회할 수 있는 별도 API 제공.
    - `@Filter` 어노테이션을 사용하여 특정 API에서만 Soft Delete된 데이터를 조회할 수 있도록 설정.
    - Soft Delete 적용 여부에 대한 플래그를 설정하고, 필요 시 `deleted_at` 컬럼을 추가하여 삭제된 시간 기준으로 관리.


### 3.2.4 **마무리 지으며**
    - 댓글 기능에서 몇 가지 미흡한 점들이 있었지만, 이후 개선할 방향을 명확히 정리할 수 있었다.
    - 쿼리DSL을 활용한 답글 개수 조회, 엔티티 최적화, Soft Delete된 댓글 조회 개선 등을 차차 해결할 예정이다.
    - 현재의 방식이 완벽하지 않지만, 앞으로 꾸준히 백엔드적인 문제점들을 개선하면서 더욱 최적화된 댓글 시스템을 구축하는 것이 목표이다.

---
[개발노트로 돌아가기](../개발노트.md)