# 개발노트: 인증 및 인가 전략

## 목차
1. 인증 및 인가 개요
2. 회원 인증 흐름
3. 토큰 인증 흐름
4. 고려해야 할 보안 이슈
5. Refresh Token 관리 정책
    - Refresh Token 저장 방식 비교
    - 선택한 방식 및 근거
6. Refresh Token 전송 방법
    - 전송 방식 비교
    - 결론

---
## 인증 및 인가 개요
애플리케이션을 이용할 때 기능도 중요하지만 그에 못지 않게 중요 한 것이 
인증(Authentication)과 인가(Authorization)다.
사용자가 작성한 글을 다른 사람이 멋대로 수정하거나 삭제할 수 있다면 이는 애플리케이션을 
망하게 하는 지름길이 될 것이다.

이러한 상황들을 예방하기 위해 우리는 인증/인가를 철저히 설정해야 한다.
이를 위해 먼저 인증 흐름을 알아보도록 하자.

---
## 회원 인증 흐름
1. 사용자가 회원 정보로 로그인을 시도한다.
2. Security와 토큰 검증을 통해 인증에 성공한다.
3. 사용자가 인증 정보를 통해 서비스를 이용한다.
4. 사용자가 로그아웃을 시도한다. (**Refresh 토큰 파기 + 관련 세션 정리**)

---
## 토큰 인증 흐름
1. 사용자가 회원 정보로 로그인을 시도하고 인증 절차가 통과하면 서버에서 **Refresh 토큰과 Access 토큰을 발급**한다.
2. 사용자는 Access 토큰의 만료 시간까지 해당 토큰으로 애플리케이션의 서비스를 이용한다.
3. Access 토큰 만료 시 사용자는 Refresh 토큰을 가지고 서버에 Access 토큰의 재발급을 요청한다.
4. 서버는 보관하고 있는 사용자의 Refresh 토큰과 사용자가 제시한 토큰이 일치하는지 검증한다.
5. 검증이 완료되면 사용자에게 새로운 Access 토큰을 재발급해준다.
6. 사용자가 로그아웃 시, **Refresh 토큰을 즉시 파기한다**.

---
## 고려해야 할 보안 이슈
애플리케이션의 보안을 위해서는 **토큰 발급과 인증**에 특별히 신경 써야 한다.
회원 인증은 토큰에서부터 시작되고 끝난다고 해도 과언이 아니다.

토큰은 위조가 될 수 없다는 보장이 있기 때문에, **토큰에 포함된 정보가 유효하며 안전하게
검증될 수 있는 것이 중요**하다.

이러한 과정에서 Access 토큰의 재발급을 위한 Refresh 토큰은 어떻게 관리하는 것이 좋을까?

---
## Refresh Token 관리 정책
### Refresh Token 저장 방식 비교
Refresh 토큰을 저장하는 방법은 크게 두 가지로 나눌 수 있다.

#### 1. Redis에 Refresh 토큰을 저장
**장점:**
- DB 조회 없이 빠른 시간 내에 토큰 관리가 가능
- TTL 설정으로 만료된 토큰을 자동으로 삭제할 수 있음

**단점:**
- **단일 Redis 서버를 사용할 경우 장애 발생 시 Refresh 토큰 데이터가 유실될 위험이 있음**
- 여러 도메인에서 Redis를 사용하면 용량 제한으로 인해 비용이 증가할 수 있음

#### 2. DB에 Refresh 토큰을 저장
**장점:**
- **데이터의 일관성과 영속성이 보장된다.**
- Redis보다 비용적 부담이 적다.

**단점:**
- Redis보다 접근 시간이 오래 걸린다.
- **만료된 토큰을 직접 삭제하는 관리 로직이 필요하다.**

### 선택한 방식 및 근거
처음 서버를 구성했을 때는 고려하지 못했던 문제였으나, **무중단 배포 및 서버 안정성 확보 후** Refresh 토큰 관리 방식을 다시 검토하였다.

또한, **AWS ElastiCache를 활용하여 Redis를 클러스터링하여 운영**함으로써 데이터의 일관성을 유지할 수 있도록 구성했다.

따라서, **빠른 조회 성능과 TTL을 활용한 자동 만료 기능을 고려하여 Redis를 활용한 Refresh 토큰 저장 방식을 채택**하였다.

---
## Refresh Token 전송 방법
### 전송 방식 비교
Refresh 토큰을 받는 방법은 세 가지 정도로 나눌 수 있다

#### 1. Body에 담아서 보내는 방법
- 브라우저 캐시에 남을 가능성이 있습니다.
- **CSRF, XSS 등의 공격으로부터 취약할 수 있다.**

#### 2. 헤더에 담아서 보내는 방법
- Authorization 헤더를 사용하면 Access 토큰과 혼동될 가능성이 있다.
- **따라서, 커스텀 헤더를 사용해야 한다.**

#### 3. 쿠키에 담아서 보내는 방법
- HTTPONLY 설정을 통해 **XSS 공격을 방어할 수 있다.**
- **하지만, CORS 설정이 복잡해질 수 있으며, 모바일 환경에서 제한이 있을 수 있다.**

### 결론
**헤더에 담아서 보내는 방식이 가장 적합**하다고 생각했다. 보편적으로 많이 사용되는 방법이며, 통신하기에 간편하기 때문이다.

따라서, **Authorization 헤더가 아닌 커스텀 헤더인 `Refresh-Token` 헤더를 사용하기로 했다.**

---


[개발노트로 돌아가기](../개발노트.md)