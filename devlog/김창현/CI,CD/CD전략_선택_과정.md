# CD 전략 선택 과정


## 무중단 배포(CD) 의 필요성
처음에는 인스턴스를 구성하고 docker를 이용해서 서버를 구성하고, ssh 접속을 통해 로컬에 있는 서버를 EC2 인스턴스에 업로드 하였다.
그러다 GitActions를 통해서 배포를 할 수 있다는 것을 알게 되었고, 이것을 적용하게 되었다. 하지만 여기까지의 상황에서는 큰 문제가 있었다.
바로 서버를 최신 릴리즈로 업데이트 할 때, 서버가 다운되고 다시 실행되는 동안 서비스를 이용하거나 테스트 할 수 없다는 것이다.
현재의 상황에서는 팀원들의 테스트만 잠시 방해가 될 뿐이었으나, 실제로 서비스를 진행할 때는 아찔한 상황이겠다는 생각이 들었다.
따라서, 무중단 배포를 진행해보고자 한다. 인스턴스 1대 이상으로 진행하고, 현재 프로젝트에 맞는 전략을 사용해서 구성을 해야 할 필요가 있다.

## 개요

무중단 배포(CD)를 구현하기에 앞서, 어떤 배포 전략을 선택할지 먼저 정리해보고자 한다.  
CD를 구현하는 대표적인 전략은 다음 세 가지로 나눌 수 있다.

- 블루/그린 배포 전략
- 롤링 배포 전략
- 카나리 배포 전략

각 전략의 장·단점을 살펴보고, 현재 프로젝트 상황에 가장 적합한 전략을 선택해보자.

---

## 블루/그린 배포

### 장점
- **무중단 배포 가능**: 사용자 요청을 새 환경으로 한 번에 전환할 수 있다.
- **롤백 용이**: 문제가 발생하면 트래픽을 이전 환경으로 즉시 되돌릴 수 있다.
- **테스트 용이성**: 실제 프로덕션과 동일한 환경에서 사전 테스트가 가능하다.

### 단점
- **리소스 비용 증가**: 두 개의 완전한 프로덕션 환경을 동시에 운영해야 한다.
- **데이터베이스 마이그레이션 복잡성**: 전환 시점에 DB 스키마 변경 등이 필요한 경우, 이를 안전하게 처리하기가 까다로울 수 있다.
- **설정 복잡성**: 부하 분산기 설정 및 환경 관리가 다소 복잡해질 수 있다.

---

## 롤링 배포

### 장점
- **리소스 효율적**: 별도의 추가 인프라 없이 기존 환경 내에서 배포 가능하다.
- **점진적 변경**: 서버를 하나씩 순차적으로 업데이트해 전체 장애 가능성을 줄일 수 있다.
- **상대적으로 간단한 구현**: 부하 분산기나 환경 분리 등 추가 구성 요소가 적다.

### 단점
- **배포 중 용량 감소**: 일부 서버가 업데이트되는 동안 전체 서비스 처리량이 줄어들 수 있다.
- **버전 호환성 이슈**: 새 버전과 기존 버전이 공존하는 동안, API나 데이터 호환성 문제 발생 가능성 존재.
- **롤백 난이도**: 전체 서버 업데이트 이후 롤백이 필요하면, 다시 전체 배포가 필요하다.

---

## 카나리 배포

### 장점
- **위험 최소화**: 소수의 사용자만 새 버전을 사용하도록 해 문제 발생 시 영향 범위를 최소화할 수 있다.
- **실제 사용자 피드백 확보**: 실제 트래픽 환경에서 새 버전에 대한 피드백을 수집할 수 있다.
- **점진적 확장 가능**: 문제가 없으면 점진적으로 새 버전의 트래픽 비율을 늘려 안정성을 확보할 수 있다.

### 단점
- **구현 난이도**: 트래픽을 특정 사용자 그룹에만 라우팅하는 로직 구현이 필요하다.
- **모니터링 부담 증가**: 두 버전에 대해 각각 성능, 오류율 등을 실시간으로 모니터링해야 한다.
- **배포 완료까지 시간 소요**: 전체 트래픽을 새 버전으로 전환하기까지 시간이 오래 걸릴 수 있다.

---

## 현재 프로젝트 상황
- Docker-compose 컨테이너 기반으로 배포 환경 구성 → 일관된 실행 환경 보장
- 2개의 인스턴스에서 AutoScaling 으로 인스턴스를 관리하면 무중단 배포 및 인스턴스의 일관성을 유지하는 것도 좋을 것이라 생각해서 AutoScaling 적용
- blue/green 환경을 구축했으나, AutoScaling으로 인스턴스 관리하며 2개/2개로 나뉘어 버전 관리가 되다 보니 인스턴스가 낭비되는 비율이 크다고 생각함
- 최신 릴리즈가 배포되었을 때, 1개의 서버만 중지되고(업데이트) 업데이트 완료 되면 테스트 후 다른 모든 인스턴스에 전파하는 것이 효율적일 것이라 생각함 

- 
---

## 결론

현재 인프라 구조상 **블루/그린 배포 전략**이 가장 적합하다.  
이미 두 개의 인스턴스를 운영 중이므로, 블루 환경과 그린 환경을 각각 매핑하여 운영할 수 있으며, 무중단 배포 및 신속한 롤백이 가능하다.

---

필요하면, 프로젝트 특성(트래픽 규모, 서비스 중요도 등)에 따라 추후 카나리 배포로 전환하는 것도 고려해볼 수 있다.


## AutoScaling에 따른 배포 전략
기존에 무중단 배포를 Blue/Green으로 바꾸니 AutoScaling으로 추가된 인스턴스의 관리가 문제였다.

autoScaling을 설정하니 모든 인스턴스의 일관성을 위해 시작 템플릿을 만드는 작업이 필요했다.

이 과정에서 고민이었던 점은 환경 변수이다. 사용자 데이터의 스크립트에서는 gitActions에서 환경변수를 가져오지 못하는데, 어떻게 해야 할 지가 고민이었다.

또한 pem파일을 통해 인스턴스에 접속하거나, 하는 등의 작업도 못하기에 어떻게 할까 고민을 했고,
s3에 퍼블릭 엑세스를 허용하지 않고, 설정파일들을 올려 거기서 환경변수를 가져오기로 결정했다.

이렇게 하면 보안 상의 이슈는 크게 발생하지 않을 것이고, 환경이 바뀐다면 ECR에서 이미지를 가져와서 빌드를 진행하기 때문에 s3에 환경 파일만 바꿔주면 되기 때문에
편의성도 보장된다.


## 트러블 슈팅
AWS의 설정 변경 커밋 완료 후 버전이 바뀜에도 커밋 내용이 반영되지 않는 문제
-> 정확한 원인을 파악하기는 어렵지만, 브라우저의 캐시 문제가 아닐까 생각한다. 시크릿 탭으로 시도하니까 바로 해결되었음.

## 전체 흐름
사용자로부터 도메인에 요청이 들어오면, Route53에서 CloudFront에 연결시켜주고, CloudFront에서는 Https 요청은 그대로 수용하고,
Http 요청은 Https로 리디렉션을 해준다. 그렇게 CloudFront에서 S3에 저장된 프론트엔드의 스냅샷으로  클라이언트를 구성하고,
클라이언트는 api 전용 서버에 요청을 보내고 ALB가 해당 요청을 받는다. ALB는 80포트로 요청을 받는데, 이것을 대상 그룹에 8080포트로
전달한다. 대상 그룹은 8080포트로 들어온 요청을 각 인스턴스에 연결해주며, 그 요청을 받은 인스턴스의 서버는 응답을 반환한다.
반환 받은 응답 정보로 클라이언트는 페이지를 리로딩하여 사용자에게 보여준다.