# Refresh Token 관리 정책

## 목차
- [회원 인증 흐름](#회원-인증-흐름)
- []

우리가 애플리케이션을 이용할 때, 가장 중요한 것은 인증(Authentication)과 인가(Authorization)이다.

사용자가 작성해 놓은 글을 다른 사람이 멋대로 수정하거나 삭제할 수 있다면 이는 애플리케이션을 망하게 하는 지름길이 될 것이다.

이러한 상황들을 예방하기 위해 우리는 인증/인가를 잘 설정해 주어야 한다.

이러한 인증/인가를 설정하기 위해 이해해야 할 인증 흐름에 대해 먼저 알아보도록 하겠다.

## 회원 인증 흐름
 
1. 사용자가 회원 정보로 로그인을 시도한다.
2. security와 토큰 검증을 통해 인증에 성공한다.
3. 사용자가 인증 정보를 통해 서비스를 이용한다.
4. 사용자가 로그아웃을 시도한다.(refresh 토큰 파기)

## 토큰 인증 흐름
1. 사용자가 회원 정보로 로그인을 시도하고 인증 절차가 통과하면 Refresh 토큰과 Access 토큰을 서버에서 발급 해 준다.
2. 사용자는 Access 토큰의 만료 시간까지 해당 토큰으로 애플리케이션의 서비스를 이용한다.
3. Access 토큰 만료 시 사용자는 Refresh 토큰을 가지고 Access 토큰의 재발급을 서버에 요청한다.
4. 서버는 보관하고 있는 사용자의 Refresh 토큰과 사용자가 제시한 토큰이 일치하는지 검증한다.
5. 검증이 완료되면 사용자에게 Access 토큰을 재발급해준다.
6. 사용자가 로그아웃 시, Refresh 토큰을 파기한다.

## 고려해야 할 보안 이슈
애플리케이션의 보안 이슈를 위해서는 토큰 발급과 인증에 신경써야만 한다.<br>
회원 인증은 토큰에서부터 시작되고 끝난다고 해도 과언이 아니다. 토큰은 위조가 될 수 없다는 보장이 있기 때문에,
토큰에 있는 정보를 통해 유저를 인증할 수만 있으면 되는 것이다(?)
~~서론
이러한 과정에서 Access 토큰의 재발급을 위한 Refresh 토큰은 어떻게 관리하는 것이 좋을까?

## Refresh Token 관리 정책
Refresh 토큰을 저장하는 방법은 크게 두 가지로 나눌 수 있을 것 같다.
1. Redis에 Refresh 토큰을 저장
2. DB에 Refresh 토큰을 저장




대충 이정도의 흐름으로 생각할 수 있을 것 같은데, 로그인 시 refresh 토큰은 어떻게 관리를 해야 할까?

로그 아웃 시에 RefreshToken을 파기 하는 것은 당연한데, 비밀번호 변경 시에도 RefreshToken을 파기해야 할 거란 말이지…
그렇다면 MemberService에서 AuthService를 의존해야 하나? 이렇게 같은 계층을 참조하는 방식은 선호하지 않는데…
왔다 갔다 하는 상황이 나올 수도 있고 고려해야 할게 많단 말이지? 그럼 동현 튜터님이 저번에 제안 해 주신 이벤트 리스너 방식은?
한번 고려 해 봐야겠다. → 이벤트 리스너 방식까지는 과하지 않을까? 서비스가 방대해진다면 그 때 fix해도 늦지 않을 것 같다

RefreshToken을 어떻게 입력받아야 할까? 토큰을 보내는 것은 Body에서는 보안 상 이슈로 보통 헤더나 쿠키에 전달될 텐데, 
Authorization 헤더를 사용해서 보내게 된다면 AccessToken과 혼용될 수 있을 듯 하다. 물론 AccessToken 앞에는 Bearer
PREFIX가 붙고, refresh의 경우 붙지 않지만, 이걸로 구분하기엔 애매한 부분이 있는 것 같다. 
(조금만 코드 수정 삑나면 골로 갈지도?) 그렇다면 커스텀 Header를 사용해서 (ex. Refresh-token)전달하거나,
Cookie를 사용해서 전달하는 방법이 있을 것 같은데, 커스텀 헤더를 사용하면 일관성 있게 보낼 수 있고 CORS 설정이
쉬운 대신 XSS 공격 등에 취약한 모습을 보인다. 쿠키의 경우 HTTPONLY 설정으로 XSS공격을 차단할 수 있지만 CORS설정이
복잡하고, 도메인 별(모바일 등)로 사용이 제한될 수 있다는 단점이 있다. → 우선은 커스텀 헤더를 사용해서 구현은 해볼건데, 
조금 더 생각해보자.
로그인 후에 로그아웃을 안하고, 타임 아웃이 되면 refreshToken은 지워져야 하겠지…? 그럼 스케줄러를 사용해야 하나?