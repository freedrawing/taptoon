# SecretKey 관리에 대한 고뇌

### 문제 상황
Jwt SecretKey를 application.yml 파일에서 fix 하는 방식은 보안 상의 이슈(한번 털리면 치명적)가 있을 것 같다.
SecretKey는 Jwt에서 토큰 발급을 위한 key 값을 생성해 내는 "key 를 위한 key값" 이라고 할 수 있다.
그렇다면, 이 secretKey 값을 잘 관리 해야 jwt토큰의 보안 이슈를 해결 할 수 있지 않을까?

**Jwt SecretKey를 어떻게 보관해야 할까?**

### Idea 1
서버를 재시작 할 때마다 secretKey 값을 `UUID.randomUUID()` 등을 통해 바꿔주는 방식을 도입 해 볼 수 있겠다.
이 방식은 매 서버의 시작 시점에 새로운 secretKey값이 할당되므로 yml파일에서 따로 관리를 하지 않아도 되고, 자주 재시작 되는 환경에서는 비밀번호가 자주 바뀌는 셈이므로 보안 상 강점을 가질 수 있을 듯 하다.

하지만, CD(무중단 배포)를 지원하는 서버라면? 상황이 달라진다.

### Idea 2

위의 방식에서 확장해서, 스케줄러를 통해 secretKey를 주기마다 바꾸는 방식은 어떨까?
이 방식 또한 좋은 해결책일 수 있으나, 전제 조건이 하나 필요하다.
**단일 서버** 환경이어야 한다는 것.
분산 서버의 경우 secretKey를 동기화 하는 비용이 반드시 발생하고, 이 과정이 잦아질수록 서버의 부담이 커지게 된다.

### Idea 3

git의 Secrets와 같은 도구를 통해 환경 변수를 git에 저장하는 방식 또한 고려해 볼 수 있다.
하지만 많은 사람들이 이용하고, 조회가 가능 한 환경인 만큼 사람의 실수로 보안 이슈가 발생할 가능성이 있다.

### Idea 4

그렇다면, Ec2를 통해 배포를 하고 있다면 EC2에 직접 환경 변수를 저장하는 방식은 어떨까?
이것 또한 좋은 해결책일 수 있으나, 단일 서버에 한해서 가능할 것 같다. 다중서버가 될 수록 일관성 유지가 어려워 질 수 있을 것 같다.

### Idea 5

그렇다면 AWS에서 제공하는 AWS Secrets Manager 등을 사용하는 방법은?
이 방식은 AWS가 해킹당하지 않는 이상 훌륭한 보안 정책이라 할 수 있다. (AWS가 털린다면 애초에 서버도 안전하다는 보장이 없기 때문에)
하지만 비용이 발생한다는 문제점이 있다. 보안이 중요하다면 이 방법을 채택하는 것도 좋을 것 같다.

### 결론

GitSecrets 에 AWS 관련 민감 정보들을 저장하고, AWS S3에 application.yml에 민감정보를 담아 업로드를 하고, S3의 인/아웃바운드, 권한 설정을 통해
접근을 제어하는 방식을 채택하였다.

* 근거
  - AWS Secrets Manager를 쓰기엔 비용 문제가 발생한다. 
  - 민감 정보를 한 곳에 전부 몰아서 보관하기 보다는 분산 저장하는 것이 더 보안 적 이점이 있다.
  - SecretKey를 동기화하는 비용 없이, 민감 정보가 바뀌게 된다면 환경 파일만 s3에 업로드 해 주면 된다.(혹은 gitSecrets 에.)