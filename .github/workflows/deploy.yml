name: Deploy to AWS with Rolling Update
on:
  push:
    branches: [ cd-deploy ]  # 메인 브랜치에 push될 때 실행

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ github.sha }}
    steps:
      - uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      - name: Build with Gradle
        uses: gradle/gradle-build-action@v2
        with:
          arguments: build -x test

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Upload docker-compose file to S3
        run: |
          aws s3 cp docker-compose.yml s3://taptoon-config/docker-compose.yml --sse AES256

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build and Push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: taptoon
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build --build-arg BUILDKIT_INLINE_CACHE=1 \
                      --cache-from $ECR_REGISTRY/$ECR_REPOSITORY:latest \
                      -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
                      -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  deploy_with_rolling:
    needs: build_and_push
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Monitor Rolling Deployment Progress
        run: |
          # 기존 인스턴스 리프레시 취소 로직
          echo "Checking for existing Instance Refresh..."
          STATUS=$(aws autoscaling describe-instance-refreshes \
            --auto-scaling-group-name "asg-taptoon" \
            --query "InstanceRefreshes[?Status=='InProgress'].Status" \
            --output text 2>/dev/null || echo "None")
          if [ "$STATUS" == "InProgress" ]; then
            echo "Instance Refresh in progress, cancelling..."
            aws autoscaling cancel-instance-refresh --auto-scaling-group-name "asg-taptoon"
            sleep 30  # 취소 작업이 반영될 시간 제공
          fi

          # 새 인스턴스 리프레시 시작
          echo "Starting new instance refresh..."
          aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "asg-taptoon" \
            --strategy "Rolling" \
            --preferences '{"MinHealthyPercentage":100,"InstanceWarmup":300,"MaxHealthyPercentage":110}'

          # SSH 키 준비
          echo "${{ secrets.EC2_SSH_KEY }}" > /tmp/ec2-ssh-key.pem
          chmod 600 /tmp/ec2-ssh-key.pem

          # 롤링 배포 모니터링 로직
          echo "Monitoring individual instance transitions..."
          START_TIME=$(date +%s)
          MAX_DURATION=1800  # 30분
          LAST_INSTANCES=""

          while [ $(($(date +%s) - START_TIME)) -lt $MAX_DURATION ]; do
            # 인스턴스 리프레시 상태 확인
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "asg-taptoon" \
              --query "InstanceRefreshes[0].Status" --output text)
            PROGRESS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "asg-taptoon" \
              --query "InstanceRefreshes[0].PercentageComplete" --output text)

            echo "Overall progress: $PROGRESS% ($STATUS)"

            # 현재 인스턴스 상태 확인
            CURRENT_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-name "asg-taptoon" \
              --query "AutoScalingGroups[0].Instances[*].[InstanceId,LifecycleState]" \
              --output json)

            # 이전과 다른 경우 변경 사항 출력
            if [ "$CURRENT_INSTANCES" != "$LAST_INSTANCES" ]; then
              echo "Instance state change detected at $(date)"
              echo "$CURRENT_INSTANCES" | jq -r '.[] | "Instance \(.[0]): \(.[1])"'

              # InService 상태 인스턴스 확인 (SSH 오류 방지를 위해 시간 지연)
              INSERVICE_INSTANCES=$(echo "$CURRENT_INSTANCES" | jq -r '.[] | select(.[1] == "InService") | .[0]')

              if [ -n "$INSERVICE_INSTANCES" ]; then
                echo "Waiting 60 seconds for instances to fully initialize..."
                sleep 60

                for INSTANCE_ID in $INSERVICE_INSTANCES; do
                  # 이전 목록에 없는 경우만 확인
                  if [ -z "$LAST_INSTANCES" ] || ! echo "$LAST_INSTANCES" | jq -r '.[] | select(.[1] == "InService") | .[0]' | grep -q "$INSTANCE_ID"; then
                    IP=$(aws ec2 describe-instances \
                      --instance-ids $INSTANCE_ID \
                      --query "Reservations[0].Instances[0].PublicIpAddress" \
                      --output text)

                    if [ -n "$IP" ]; then
                      echo "Checking instance $INSTANCE_ID ($IP)..."

                      # 먼저 SSH 연결 테스트
                      if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i /tmp/ec2-ssh-key.pem ubuntu@$IP echo "SSH connection successful" 2>/dev/null; then
                        echo "SSH connection to $IP successful, checking health..."

                        # 헬스 체크 (HTTP 요청)
                        HEALTH=$(ssh -o StrictHostKeyChecking=no -i /tmp/ec2-ssh-key.pem ubuntu@$IP "curl -s localhost:80/health" 2>/dev/null || echo "DOWN")

                        if echo "$HEALTH" | grep -q "UP"; then
                          echo "✅ Instance $INSTANCE_ID is healthy"
                        else
                          echo "⚠️ Instance $INSTANCE_ID health check failed, but continuing"
                        fi
                      else
                        echo "⚠️ SSH connection to $IP failed, instance may not be fully initialized"
                      fi
                    else
                      echo "⚠️ No public IP found for instance $INSTANCE_ID"
                    fi
                  fi
                done
              fi

              LAST_INSTANCES="$CURRENT_INSTANCES"
            fi

            if [ "$STATUS" == "Successful" ]; then
              echo "✅ Rolling deployment completed successfully!"
              break
            elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ]; then
              echo "❌ Rolling deployment failed: $STATUS"

              # 실패 원인 확인
              FAILURE_REASON=$(aws autoscaling describe-instance-refreshes \
                --auto-scaling-group-name "asg-taptoon" \
                --query "InstanceRefreshes[0].StatusReason" --output text)
              echo "Failure reason: $FAILURE_REASON"
              exit 1
            fi

            sleep 30
          done

          # 시간 초과 확인
          if [ $(($(date +%s) - START_TIME)) -ge $MAX_DURATION ]; then
            echo "❌ Deployment timed out after 30 minutes"
            exit 1
          fi

          rm -f /tmp/ec2-ssh-key.pem

  health_check:
    needs: deploy_with_rolling
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Check ASG instance health
        run: |
          INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-name "asg-taptoon" \
            --query "AutoScalingGroups[0].Instances[?LifecycleState=='InService'].InstanceId" \
            --output json)
          for INSTANCE_ID in $(echo "$INSTANCES" | jq -r '.[]'); do
            IP=$(aws ec2 describe-instances \
              --instance-ids $INSTANCE_ID \
              --query "Reservations[0].Instances[0].PublicIpAddress" \
              --output text)
            if [ -z "$IP" ]; then
              echo "No public IP for $INSTANCE_ID, skipping..."
              continue
            fi
            echo "Checking health on $IP..."
            HEALTH=$(curl -s "http://$IP:8080/health" || echo "DOWN")
            if echo "$HEALTH" | grep -q "UP"; then
              echo "Instance $INSTANCE_ID ($IP) is healthy!"
            else
              echo "Instance $INSTANCE_ID ($IP) is unhealthy!"
              exit 1
            fi
          done

  cleanup_ecr:
    needs: deploy_with_rolling
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Clean up old ECR images
        env:
          ECR_REPOSITORY: taptoon
        run: |
          IMAGES_TO_DELETE=$(aws ecr describe-images \
            --repository-name $ECR_REPOSITORY \
            --query 'sort_by(imageDetails,& imagePushedAt)[:-5].imageDigest' \
            --output json)
          if [ "$IMAGES_TO_DELETE" != "[]" ] && [ "$IMAGES_TO_DELETE" != "" ]; then
            for digest in $(echo $IMAGES_TO_DELETE | jq -r '.[]'); do
              aws ecr batch-delete-image \
                --repository-name $ECR_REPOSITORY \
                --image-ids imageDigest=$digest
            done
            echo "Old ECR images cleaned up"
          else
            echo "No old ECR images to clean up"
          fi